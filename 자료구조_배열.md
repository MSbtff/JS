## 자료구조

### 자료 구조

데이터란 무엇일까

데이터는 일반적으로 모든 유형의 정보를 망라하는 용어이며 가장 기초적인 수와 문자열로 이뤄진다. 간단하지만 고전적인 'Hello World' 프로그램을 떠올리면 'Hello World!' 문자열이 바로 데이터다. 매우 복잡한 데이터라도 대개는 수와 문자열 묶음으로 나뉜다.

자료구조란 데이터를 조작하는 방법이다. 같은 데이터를 어떻게 다양한 방식으로 조직할 수 있는지 배우겠다.



```
x = 'Hello'
y = 'How are you'
z = 'today?'

print x + y + z
```



문자열 세 개를 하나의 메시지로 이어 출력하는 매우 간단한 프로그램이다.

위 프로그램이 데이터를 어떻게 조직했는지 다음과 같이 설명할 수 있다.

문자열 세개가 있고, 각 문자열에 변수가 하나씩 연결되어 있다.

하지만 같은  데이터를 다음과 같이 배열에 저장할 수 있다.



```
array = ['Hello!', 'How are you', 'today?']
print array[0] + array[1] + array[2]
```

데이터 조직이 코드의 실행 속도에 미치는 영향이 크다는 것을 알려고 한다.

데이터를 어떻게 조직하는가에 따라 프로그램은 수십 수백 배 더 빠르게 혹은 더 느리게 실행될 수 있다. 대량의 데이터를 처리해야 하는 프로그램이나 수천 명이 동시에 사용하는 웹 앱을 개발한다고 가정하자

선택한 자료 구조가 소프트웨어가 잘 실행될지 혹은 처리량을 감당할 수 없어 멈춰버릴지를 결정할지도 모른다.

소프트웨어를 문제없이, 빠르게 실행할 수 있는 명쾌한 코드를 작성하는 능력을 갖추고 소프트웨어 공학자가 가져야 하는 전문성을 키우려면 다양한 자료 구조를 알고, 각각의 자료 구조가 개발중인 프로그램의 성능에 어떤 영향을 미칠지 확실히 이해하고 있어야 한다.



### 배열: 기초 자료 구조

배열은 컴퓨터 과학에서 기초적인 자료 구조 중 하나이다. 배열은 단순히 데이터 원소들의 리스트임을 알 것이다. 배열은 다양한 용도로 여러 가지 상황에서 유용한 도구로 쓰이지만, 여기서는 간단한 예제를 다뤄보자

마트에서 살 쇼핑 목록을 만들고 사용할 수 이쓴ㄴ 애플리케이션의 소스 코드를 보는 중이라면 

```
array= ['apples', 'bananans', 'cucumbers', 'dates', 'elderberries']
```

배열에만 쓰이는 기술 용어를 알아보자

배열이 인덱스는 특정 데이터가 배열의 어디에 있는지 알려주는 숫자다.

대부분이 프로그래밍 언어에서 인덱스는 0부터 시작한다.



#### 자료구조 연산

배열 같은 자료 구조의 성능을 알려면 코드가 자료 구조와 일반적으로 어떻게 상호작용하는지 분석해야 한다.

대부분의 자료 구조는 네 가지 기본 방법을 사용하며, 이를 연산이라 부른다.

읽기, 검색, 삽입, 삭제

- 읽기: 읽기는 자료 구조 내 특정 위치를 찾아보는 것. 배열에서는 특정 인덱스의 값을 찾아보는 것을 뜻함
- 검색: 검색은 자료 구조 내에서 특정 값을 찾는 것이다. 배열에서는 특정 값이 배열에 들어 있는지, 만약 그렇다면 어떤 인덱스에 있는지 알아보는 것 예를들어 'dates' 가 식료품 목록에 있는지, 어떤 인덱스에 있는지 알아보는 게 배열 검색
- 삽입: 삽입은 자료 구조에 새로운 값을 추가한는 것이다. 배열이라면 배열 내에 슬롯을 더 만들어 새 값을 추가하는 것을 뜻한다. 앞서 쇼핑 목록에 'figs'를 추가하는 게 배열에 새 값을 삽입하는 예다
- 삭제: 삭제는 자료 구조에서 값을 제거하는 것이다. 배열에서는 배열의 값 중 하나를 제거하는 것을 뜻한다. 예를 들어 예제의 식료품 목록에서 'bananas'를 제거하는 게 배열 삭제다.

### 

### 속도 측정

연산의 속도는 하드웨어에 따라 측정 시간이 다 달라질 수 있기에 얼마나 많은 계산 단계가 필요한가를 따져 볼 수 있다. 연산 A에 5단계가 필요하고 연산 B에 500 단계가 필요하면, 모든 하드웨어에서 연산 A가 연산 B보다 항상 빠를 거라고 가정할 수 있다.

연산의 속도 측정은 연산의 시간 복잡도 측정으로 알려저 있다. 



### 읽기

읽기는 배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾아보는 것이다.

컴퓨터는 딱 한 단계로 배열에서 읽을 수 있다. 배열 내 특정 인덱스에 한 번에 접근해서 볼 수 있기 때문이다. 앞선 ['apples', 'bananas', 'cucumbers', 'dates', 'elderberries'] 예제에서 인덱스 2를 찾아본다면 컴퓨터는 인덱스 2로 바로 가서 'cucumbers' 라는 값이 있다고 알려 준다.

컴퓨터는 어떻게 단 한 단계로 배열의 인덱스를 찾아 볼 수 있을까? 그 방법은 다음과 같다

컴퓨터의 메모리는 셀로 구성된 거대한 컬렉션이라 할 수 있다. 다음과 같은 격자로 된 셀을 보여준다. 어떤 셀을 비어있고, 어떤 셀에는 데이터가 들어 있다.

프로그램에서 배열을 선언하면 컴퓨터는 프로그램이 쓸 수 있는 연속된 빈셀들의 집합을 할당한다. 예를 들어 원소 다섯 개를 넣을 배열을 생성하면 컴퓨터는 한 줄에서 5개의 빈 셀 그룹을 찾아 사용자가 사용할 배열로 지정한다.

컴퓨터 메모리 내에 각 셀에는 특정 주소가 있다. 각 셀의 메모리 주소는 앞 셀의 주소에서 1씩 증가한다. 

컴퓨터가 배열의 특정 인덱스에 있는 값을 읽을 때 한 번의 단계로 바로 갈 수 있는데는 컴퓨터가 지닌 다음과 같은 특징들이 복합적으로 작용한다.

1. 컴퓨터는 모든 메모리 주소에 한 번에 갈수 있다.
2. 컴퓨터는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지도 기록해 준다.



### 검색

배열 검색은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것이다.

어떻게 보면 읽기와 반대다. 읽기는 컴퓨터에 인덱스를 제공하고 그 인덱스에 들어 있는 값을 반환하라고 요청한다면 검색은 컴퓨터에 값을 제공하고 그 값이 들어 있는 인덱스를 반환하라고 요청한다.

비슷해 보이지만 효율성 측면에서 어마어마하게 다르다. 인덱스에서 읽기는 컴퓨터가 어떤 인덱스든 바로 가서 인덱스에 있는 값을 찾을 수 있으니 매우 빠르다 이와 달리 검색은 컴퓨터가 특정 값으로 바로 갈 수 없으니 오래 걸린다.

이것이 컴퓨터의 중요한 특징이다. 컴퓨터는 모든 메모리 주소에 한 번에 접근하지만 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.

예를 들어 과일 과 야채 배열 예제를보면 컴퓨터는 각 셀에 실제 어떤 내용이 들어 있는지 바로 알 수 없다. 컴퓨터에서 배열은 꼭 다음 처럼 보인다.

배열에서 과일을 찾으려면 컴퓨터는 각 셀을 한 번에 하나씩 조사하는 방법밖에 없다.

다음의 그림은 컴퓨터가 쇼핑 목록 배열 내에서 'dates'를 찾는 과정을 보여준다.

컴퓨터는 가장 먼저 인덱스 0을 확인한다.

인덱스 0에 있는 값은 현재 찾고 있는 'dates'가 아닌 'apples' 이므로 컴퓨터는 다음 그림에서 보듯이 다음 인덱스로 이동해서 검색을 계속한다.

인덱스 1도 현재 찾고 있는 'dates'를 포함하지 않으므로 컴퓨터는 인덱스 2로 이동해서 검색을 계속한다.

이렇게 인덱스 3에 'dates'가 있으면 총 4단계에 걸려 찾았다고 볼 수 있다.

이렇게 한 번에 한 셀씩 확인하는 방법을 선형 검색이라고 부른다.

그렇다면 컴퓨터가 배열에서 선형 검색을 수행하는데 필요한 최대 단계 수는 얼마일까?

'elderberries'처럼 찾고 있는 값이 배열의 마지막 셀에 있다면 컴퓨터는 이 값을 발견할 때 까지 배열의 모든 셀을 검색해야 한다. 또한 찾고 있는 값이 배열의 어떤 셀에도 없으며 마찬가지로 모든 셀을 검색해야 비로소 배열에 값이 없다고 확신할 수 있다.

따라서 5개의 셀로 이뤄진 배열에서 선형 검색에 걸리는 최대 단계 수는 5다. 500개의 셀로 이뤄진 배열이라면 선형 검색에 걸리는 최대 단계 수는 500이다.

달리 표현하면 N개의 셀로 이뤄진 배열은 선형 검색에 최대 N개의 단계가 필요하다고 말할 수 있다.

이때 N은 어떤 수든 넣을 수 있는 단순한 변수다.

어쨋든 검색은 읽기보다 분명히 덜 효율적이다. 읽기는 배열이 얼마나 크든 항상 한 단계만 걸리지만 검색에는 많은 단계가 걸릴 수 있다.

### 삽입

배열에 새 데이터를 삽입하는 연산은 배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.

쇼핑 목록의 맨 끝에 'figs'를 추가해 보자 이 삽입에는 딱 한 단계만 필요하다.

이는 컴퓨터의 또 다른 특징, 즉 배열을 할당할 때 항상 배열의 크기를 기록한다는 특징에 기인한다.

앞서 컴퓨터는 배열이 시작되는 메로리 주소를 안다고 했으니 두 특징 맞 몰려 생각해 보면 배열 마지막 항목의 메모리 주소를 계산하기 아주 쉽다. 배열이 메모리 주소 1010에서 시작하고 크기가 5면 마지막 메모리 주소가 1014다 따라서 그 뒤에 항목을 삽입하면 다음 메모리 주소인 1015에 항목을 추가한다는 뜻이다.

이제 컴퓨터는 새 값을 삽입할 메모리 주소를 계산할 수 있고, 이는 한 단게면 된다.

배열 끝에 'figs'를 삽입하면 다음과 같다.

하지만 한 가지 문제가 있다. 애초에 컴퓨터는 배열에 5개의 메모리 셀을 할당했고 6번째 원소를 추가하려면 이 배열에 셀을 추가로 할당해야할 수 있다. 많은 프로그래밍 언어가 내부에서 자동으로 처리하지만 

앞선 예처럼 배열 끝에 삽입하는 것이 아니라 배열의 맨 처음이나 중간에 데이터를 삽입하면 문제가 달라진다. 이때는 삽입할 공간을 만들기 위해 많은 데이터 조각을 이동시켜야 하므로 단계가 늘어난다.

예를들어 배열의 인덱스 2에 'figs'를 추가해 보자 ['apples', 'bananas', 'cucumbers', 'dates', 'elderberries'] cucumbers 부터 오른쪽으로 옮겨서 figs를 넣을 공간을 만들어야 한다. 하지만 여기에도 몇 개의 단계가 필요하다 'dates'를 옮길 공간을 만들려면 먼저 'elderberries'를 한 셀 오른쪽으로 옮겨야 한다음 'cucumbers'를 위한 공간을 만들려면 dates를 옮겨야 한다.

즉 데이터를 삽입할려면 4단계가 필요함을 알았다.  데이터를 오른쪽으로 옮기는 3단계와 실제로 새 값을 삽입하는 1단계이다.

배열 삽입에서 최악의 시나리오, 즉 삽입에서 가장 많은 단계에가 걸리는 시나리오는 데이터를 배열의 맨 앞에서 삽입할 때다. 배열의 앞에 삽입하면 배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 하기 때문이다.

다시 말해 원소 N개를 폼하는 배열에서 최악의 시나리오일 때 삽입에는 N + 1단계가 걸린다. N개의 원소를 전부 이동시키고 끝으로 실제 삽입 단계를 실행해야 하기 때문

### 삭제

배열의 삭제는 특정 인덱스의 값을 제거하는 과정

원래의 예제 배열로 돌아가서 인덱스의 2의 값을 삭제해 보자. 값은 'cucumbers'다.

그림에서 보듯이 전체 삭제 연산에 3단계가 필요했다. 첫 번째 단계가 실제 삭제이고 나머지 두 단계는 빈 공간을 메꾸는 데이터 이동이다. 삽입과 비슷하게 원소 삭제에서 최악의 시나리오는 배열의 첫 번째 원소를 삭제하는 것이다. 이렇게 되면 인덱스 0이 비게되고 남아 있는 모든 원소르 왼쪽으로 이동시켜 빈 공간을 채워야 한다.

원소 5개를 포함하는 배열이면 1단게는 첫 번째 원소의 삭제에, 4단계는 남아 있는 원소 4개를 이동하는 데 쓰인다. 원소가 500개인 배열이면 1단계는 첫 번째 원소의 삭제에, 499단계는 남은 데이터를 이동하는 데 쓰인다. 따라서 원소 N개를 포함하는 배열에서 삭제에 필요한 최대 단계 수는 N단계라고 할 수 있다.

####  

### 집합: 단 하나의 규칙으로 효율성이 달라진다.

또 다른 자료 구조인 집합을 파헤쳐 보자. 집합은 중복 값을 허용하지 않는 자료 구조다.

실제로 집합의 종류는 꽤 다양하지만 여기서는 배열 기반 집합을 다룬다. 배열 기반 집합은 값들의 단순 리스트로 배열과 거의 비슷하다. 배열 기반 집합과 일반적인 배열 간 유일한 차이점은 집합은 중복값의 삽입을 절대 허용하지 않는다.

예를 들어 ['a', 'b','c'] 라는 집합에 또 다른 'b'를 추가하려고 하면 컴퓨터는 'b'가 이미 집합에 있으므로 삽입을 허용하지 않는다.

즉  집합은 중복데이터가 없어야할 때 유용하다.

배열 기반 집합은 중복 금지라는 제약이 하나 더 추가된 배열이다. 중복을 허용하지 않는 기능이 유용하기는 하나 이 간단한 제약으로 인해 네 주요 연산 중 하나에서 집합의 효율성이 크게 달라진다.

배열 기반 집합을 가지고 읽기와 검색, 삽입, 삭제 연산을 분석하면



집합에서의 읽기는 배열 읽기와 같다. 컴퓨터는 특정 인덱스에 들어 있는 값을 한 단계 만에 찾는다.

이전에 설명한 대로 컴퓨터는 메모리 주소를 쉽게 계산해서 접근할 수 있으므로 집합 내 어떤 인덱스든 갈 수 있다.



집합의 검색도 배열의 검색과 아무런 차이가 없다. 집합에서 어떤 값을 찾는데 최대 n 단계가 걸린다.

삭제도 배열과 집합에서도 동일하다. 값을 삭제하고 데이터를 왼쪽으로 옮겨 빈 공간을 메꾸는 데 최대 n단계가 걸린다.



 삽입만큼은 배열과 집합이 다르다. 배열에서 최선의 시나리오였던 맨 끝에 삽입하는 경우를 먼저 생각해 보면 배열에서는 컴퓨터는 1단계로 값을 끝에 삽입하지만 집합에서는 먼저 이 값이 이미 집합에 들어 있는지 결정해야 한다. 중복 데이터를 막는게 바로 집합의 역할이기 때문

컴퓨터는 새 데이터가 집합에 없다고 어떻게 확신할까? 앞서 말했듯이 컴퓨터는 배열이나 집합의 셀에 어떤 값이 들어 있는지 바로 알 수 없다. 그러니 삽입하려는 값이 집합에 이미 있는지부터 먼저 검색해야 한다. 집합에 새 값이 없을 때에만 컴퓨터는 삽입을 허용한다.

따라서 모든 삽입에는 검색이 우선이다.

즉 집합의 끝에 삽입하려면 원소 n개에 대해 최대 N +1 단계가 필요하다. 값이 집합에 없음을 확인하는 데 n 단계의 검색을, 이어서 실제 삽입에  1단계를 쓰기 때문. 맨 끝에 삽입하는데 1단계밖에 걸리지 않는 일반적인 배열과 대조된다.

값을 집합의 맨 앞에 삽입하는 최악의 시나리오일 때 컴퓨터는 셀 n개를 검색해서 집합이 그 값을 포함하지 않음을 확인한 후, 또 다른 n단계로 모든 데이터를 오른쪽으로 옮겨야 하며, 마지막 단계에서 새 값을 삽입해야 한다. 총 2n + 1 단계다. 맨 앞에 삽입하는데 N + 1 단계 밖에 걸리지 않는 일반적인 배열과 대조된다.

그렇다면 삽입이 일반적인 배열보다 집합에서 느리다는 이유만으로 집합에서 쓰면 안될까? 물론 아니다 중복 데이터가 없어야 할 때는 집합이 합리적이다. 하지만 이러한 요구사항이 없다면 집합 삽입보다 배열 삽입이 더 효율적이므로 배열이 나올 수 있다.

애플리케이션의 요구사항을 먼저 분석한 후 어떤 자료구조가 더 적합한지 결정해야 한다.