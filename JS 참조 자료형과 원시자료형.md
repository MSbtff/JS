# 참조 자료형과 원시자료형

## 원시 타입과 객체 타입

자바스크립트가 제공하는 7가지 데이터 타입은 크게 원시타입과 객체타입으로 구분할 수 있다. 데이터 타입을 원시 타입과 객체 타입으로 구분하는 이유는 무엇일까?

원시 타입과 객체타입은 근본적으로 다르다는 의미 세가지 측면에서 다른데

- 원시 타입의 값은 변경 불가능한 값(immutable value)
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장 됨 
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 이를 값에 의한 전달(pass by value)라 함



객체 타입은

- 변경 가능한 값(mutable value)
- 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 이를 참조에 의한 전달(pass by reference)



### 원시 값

원시 타입은 변경이 불가능한 값으로 즉 한번 생성된 원시 값은 읽기 전용 값으로서 변경 불가능

자세히 말해보자면 **변수**는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고  **값**은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말함 즉 **변경이 불가능하다는 것은 변수가 아니라 값에 대한 진술** 



```javascript
// const 키워드를 사용해 선언한 변수는 재할당이 금지된다. 상수는 재할당이 금지된 변수일 뿐
const 0 = {};

// const 키워들 사용해 선언한 변수에 할당한 원시 값을 변경할 수 없다.
// 하지만 const 키워드를 사용해 선언한 변수에 할당한 객체는 변경할 수 있음
o.a =1;
console.log(o) //{a:1}
```



원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다



```javascript
let name = 'cookie';
let color = '삼색이';
let age = 2;
```

![img](https://blog.kakaocdn.net/dn/qdZvF/btroVkgIHcc/ELqc57XxKxmYWZAFZU3poK/img.png)

원시 값은 스택 영역에 값 자체를 보관하게 됨

엄격하게 표현하면 변수에는 값이 전달되는 것이 아닌 **메모리 주소**가 전달 되는 것으로 이는 **변수와 같은 식별자**는 값이 아니라 메모리 주소를 기억하고 있기 때문



### 참조 값

참조에 대표적인 값은 객체 값이다 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있으며 프로퍼티의 값에도 제약이 없다 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

원시 값은 상대적으로 적은 메모리를 소비하지만 객체는 경우에따라 크기가 천자만별이다. 비용도 마찬가지

그래서 객체는 참조 타입의 값 즉 **변경이 가능한 값**이다



![img](https://blog.kakaocdn.net/dn/cyqjg5/btroT7aT6D3/L3KhV9jyFqpW0tFsUlIb7k/img.png)

객체 생성시 힙 메모리에 객체 인스턴스를 생성하고 이 인스턴스가 존재하는 위치를 스택 메모리에 기록하여 사용 합니다

일반 적으로 변수에 객체를 할당 할 경우 변수는 객체를 가리키고 있다라고 표현한다. 즉 원시 값은 변경이 불가능 하므로 값을 변경할려면 재할당 외에는 방법이 없다. 하지만

객체는 변경이 가능하므로 변수에 재할당이 없이 객체를 직접 변경할 수 있다. 즉 동적으로 프로퍼티를 추가, 삭제를 할 수 있다.



### 얕은 복사와 깊은 복사



![img](https://blog.kakaocdn.net/dn/ptqsU/btroT5KVCJ4/JHliWBy6JRYnyME7cKDW8K/img.png)

객체가 생성하게 될 때 힙 영역에 저장하고 스택 메모리에 힙 영역에 저장주소를 기록함 같은 내용을 가진 객체이지만 다른 주소를 가지고 있고 다른 영역에 저장하게 됨 그래서 === 를 사용 false가 나옴 **참조 타입의 비교는** **힙 영역에 저장된 메모리 주소**를 비교하기 때문





![img](https://blog.kakaocdn.net/dn/FyAKA/btroXOn5xmI/t2lXlK5rNme4AHd6zQkayK/img.png)



새로운 변수에 기존 객체를 할당하는 경우 힙 영역의 위치를 가리키는 주소를 복제하게 됨

변수명은 다르지만 힙 영역에 동일한 객체를 가리키게 됨

자바스크립트에서 참조 타입의 데이터를 메모리에 저장하는 이러한 특징 때문에 주의를 해야함 위의 경우 cat과 cat2가 하나의 객체를 가리키고 있기에 cat을 수정할 경우 cat2에도 수정된 데이터가 출격됨 이유는 같은 주소를 가리키며 동일한 객체를 공유하고 있기 때문에 이런 것을 **얕은 복제 Shallow Copy**라고 부름

주소 복제가 아닌 다른 메모리에 객체를 똑같이 복제하고 싶다면 깊은 복제 Deep Copy를 해야하며 변수명을 복제하지 않고, 객체에 속한 모든 내용을 복제할 수 있음 이 때 **객체 프로퍼티에 참조값이 저장되어 있는 부분을 주의해 복제해야함**

Object() 함수를 사용하면 깊은 복제가 된다

즉 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시값 처럼 완전한 복사본을 만든다는 차이가 있다.